"""
Graph Network global parameters
"""
type GraphNetwork @entity {
  "id = 1"
  id: ID!
  "Contract address"
  graphToken: Bytes!
  "Contract address"
  epochManager: Bytes!
  "Contract address"
  curation: Bytes!
  "Contract address"
  staking: Bytes!
  "Contract address"
  disputeManager: Bytes!
  "Contract address"
  gns: Bytes!
  "Contract address"
  serviceRegistry: Bytes!
  # "Set to true if the protocol is paused" TODO - add when implemented
  # paused: Boolean!

  # Staking global variables
  "Percentage of fees going to curators"
  curationPercentage: BigInt!
  # "Capacity of staked delegation tokens to own stake"  TODO - add when implemented
  # delegationCapacity: Int!
  "Period to wait before fees can be claimed in rebate pool"
  channelDisputeEpochs: BigInt!
  "Period to wait before delegators can settle"
  maxAllocationEpochs: BigInt!
  "Time in blocks needed to wait to unstake"
  thawingPeriod: BigInt!
  # "All addresses that have slashing privileges" TODO - add when implemented
  # slashers: [Bytes!]!
  # "Minimum time an Indexer must use for resetting their Delegation parameters" TODO - add when implemented
  # minDelegationParameterCooldown: Int!
  # "The number of indexing rewards handed out per epoch" TODO - add when implemented
  # indexingRewardsPerEpoch: Int!
  # "The issuance rate that GRT is minted at to support Indexers of the protocol" TODO - add when implemented
  # networkGRTIssuance: Int!
  "The total amount of GRT staked in the staking contract"
  totalGRTStaked: BigInt!
  "Total tokens that are settled and waiting to be claimed"
  totalGRTClaimable: BigInt!
  "Total tokens that are currently locked in the network"
  totalGRTLocked: BigInt!
  "Total GRT currertly in allocation"
  totalGRTAllocated: BigInt!

  # Curation global variables
  "Default reserve ratio for all subgraphs"
  defaultReserveRatio: BigInt!
  "Minimum amount of tokens needed to start curating"
  minimumCurationSignal: BigInt!
  "The total amount of GRT staked in the Curation contract"
  totalGRTSignaled: BigInt!

  # Graph Token global variables
  "Graph Token supply"
  totalSupply: BigInt!

  # Epoch Manager global variables TODO - add in after beta
  # "Epoch Length in blocks"
  # epochLength: Int!
  # "Epoch that was last run"
  # lastRunEpoch: Int!
  # "Epoch when epoch length was last updated"
  # lastLengthUpdateEpoch: Int!
  # "Block when epoch length was last updated"
  # lastLengthUpdateBlock: Int!

  # Dispute Manager global variables TODO - add in after beta
  # "Address with permission to verify or reject disputes"
  # arbitrator: Bytes!
  # "Minimum deposit to create a dispute"
  # minimumDisputeDeposit: BigInt!
  # "Reward to Fisherman on successful disputes"
  # fishermanRewardPercentage: BigInt!
  # "Penalty to Indexer on successful disputes"
  # slashingPercentage: BigInt!
}

# TODO - Will probably remove this after beta
# """EthereumAccount is a user in the front end which could be doing any actions"""
# type EthereumAccount @entity {
#   "Eth address"
#   id: ID!

#   # From Graph Token
#   "Graph token balance"
#   balance: BigInt!

#   # Identities
#   "Graph accounts this ethereum account is an owner of"
#   ownerOf: [GraphAccount!]! @derivedFrom(field: "owner")
#   # "Graph account organizations this ethereum account is a member of" # add back when we support DAOS as contracts
#   # organizationMemberOf: [GraphAccount!]! @derivedFrom(field: "members")

#   # From Staking and Curating and Delegating
#   "Subgraphs this account curates"
#   curator: Curator
#   "Subgraphs this account indexes"
#   indexer: Indexer
#   "Subgraphs this account has delegated to"
#   delegator: Delegator
# }

"""
An account within the graph network. An account can own multiple names from multiple name systems
"""
type GraphAccount @entity {
  "Graph account ID"
  id: ID!
  "All names this graph account has claimed from all name systems"
  names: [GraphAccountName!]! @derivedFrom(field: "graphAccount")
  # "Default name system to show up in the Graph Explorer. Null if not specified"
  # defaultName: GraphAccountName TODO - might delete, being renamed to name from erc-1056 set attribute
  "From IPFS"
  name: String!
  "Time the account was created"
  createdAt: Int!
  # "True if it is an organization. False if it is an individual"
  # isOrganization: Boolean!
  # "Members of the organization" # Add back when we support daos as contracts
  # members: [EthereumAccount!]!
  "Subgraphs the graph account owns"
  subgraphs: [Subgraph!]! @derivedFrom(field: "owner")

  "IPFS hash with account metadata details"
  metadataHash: Bytes
  "Main repository of code for the graph account"
  codeRepository: String
  "Description of the graph account"
  description: String

  "Image in string format"
  image: String
  "Website URL"
  website: String

  # Identities TODO - implement this after Beta. ERC-1056 changing of ownership
  # "Owner of this graph account"
  # owner: GraphAccount!
  # "Graph accounts this ethereum account is an owner of"
  # ownerOf: [GraphAccount!]! @derivedFrom(field: "owner")
  # "Delegate of"
  # delegateOf: [GraphAccount!]! @derivedFrom(field: "delegates")
  # "Delegates"
  # delegates: [GraphAccount!]!
  # From Graph Token
  "Graph token balance"
  balance: BigInt!

  # From Staking and Curating and Delegating
  "Subgraphs this account curates"
  curator: Curator
  "Subgraphs this account indexes"
  indexer: Indexer
  "Subgraphs this account has delegated to"
  delegator: Delegator
}

"""
A name and a name system. A graph account can own many names from many systems
"""
type GraphAccountName @entity {
  "Name system concatenated with the unique ID of the name system"
  id: ID!
  "Name system for this name"
  nameSystem: NameSystem!
  "Name resolved from whatever system is used"
  name: String!
  "The graph account that owned the name when it was linked in the graph network. May not match if the graph account proceeded to transfer away their name on that system"
  graphAccount: GraphAccount!
}

enum NameSystem {
  ENS
  Everest
  Github
}

"""
All the information related to the name that is in the GNS
"""
type Subgraph @entity {
  "Subgraph ID derived from the Organization/Individual graph accountID"
  id: ID!
  "Graph account that owns this subgraph"
  owner: GraphAccount!
  "Current version. Null if the subgraph is deprecated"
  currentVersion: SubgraphVersion
  "Past versions"
  pastVersions: [SubgraphVersion!]!
  "Creation timestamp"
  createdAt: Int!

  # From Curation, the name specific bonding curve TODO - add when implemented
  # "Total GRT signaled for the name"
  # totalNameSignaledGRT: BigInt!
  # "Total name signal minted for this subgraph"
  # totalNameSignalMinted: BigInt!

  # From GNS
  "Name of the subgraph. Name is set to null if subgraph is deprecated"
  name: GraphAccountName
  "Past names that has been associated with this subgraph, with version number"
  pastNames: [GraphAccountName!]!

  # Metadata from IPFS linked in GNS
  "Subgraph metadata"
  metadataHash: Bytes!
  "Short description of the subgraph"
  description: String!
  "Image in string format"
  image: String!
  "Location of the code for this project"
  codeRepository: String!
  "Project's website"
  website: String!

  # TODO - add these later in the event that this is implemented :
  # https://www.notion.so/thegraph/Graph-Name-Service-Signaling-30e72e7f1b3c46a4a6b224155e5a6612#a379698b83c241208b6929a1788bcf4e

  # Aggregate data
  # "Total inflation rewards earned all time by this subgraph"
  # totalSubgraphIndexingRewards: BigInt!
  # "Total query fees earned by this subgraph"
  # totalQueryFeesCollected: BigInt!
  # "Total stake of all indexers on all subgraph versions"
  # totalStake: BigInt!
  # "Total signal of all curators on all subgraph versions"
  # totalSignal: BigInt!
}

"""
Contains all the version metadata
"""
type SubgraphVersion @entity {
  "Concatenation of subgraph, subgraph deployment, and version ID"
  id: ID!
  "Subgraph of this version"
  subgraph: Subgraph!
  "Subgraph depolyment of this version"
  subgraphDeployment: SubgraphDeployment!
  "Version number"
  version: Int!
  "Creation timestamp"
  createdAt: Int!

  # Metadata from IPFS linked in GNS
  "Subgraph version metadata content address"
  metadataHash: Bytes!
  "Short description of the version"
  description: String!
  "A human readable name. If not set, blank string"
  label: String!
}

"""
The immutable subgraph deployment defined by a subgraph manifest that Indexers stake on and Curators signal on
"""
type SubgraphDeployment @entity {
  "Subgraph Deployment ID"
  id: ID!
  "The versions this subgraph deployment relates to"
  versions: [SubgraphVersion!]! @derivedFrom(field: "subgraphDeployment")
  "Creation timestamp"
  createdAt: Int!

  # From Staking
  "Total stake of all indexers on this Subgraph deployment"
  totalStake: BigInt!
  "Indexers of this subgraph deployment"
  indexerAllocations: [Channel!]! @derivedFrom(field: "subgraphDeployment")
  "Total fees accrued all time by this subgraph deployment"
  totalSubraphIndexingRewards: BigInt!
  "Total query fees earned by this subgraph deployment"
  totalQueryFeesCollected: BigInt!

  # From Curation, the deployment specific bonding curve
  "Total signal of all curators"
  totalSignaledGRT: BigInt!
  "Total curation signal on this subgraph deployment"
  totalSignalMinted: BigInt!
  "Total curator reward from fees"
  totalCuratorFeeReward: BigInt!

  "Curators of this subgraph deployment"
  curatorSignals: [Signal!]! @derivedFrom(field: "subgraphDeployment")
  "Bonding curve reserve ratio"
  reserveRatio: BigInt

  # From Subgraph Manifest
  # dataSources: [DataSource!] # TODO - add a ! when we have the ability to parse data sources
}

# TODO - add when we have the ability to parse data sources
# """Data source obtained from the subgraph manifest"""
# type DataSource @entity {
#   "Unique identifier of the data source. Such as contract address"
#   id: ID!
#   "Data source name in the manifest"
#   name: String!
#   "Networks that the subgraph deployment is indexing"
#   networks: [String!]!
#   "Contract"
#   contract: Contract!
#   "ABI of the contract"
#   abi: String!
# }

# type Contract @entity {
#   "Address of the contract"
#   id: ID!
#   "Contract name"
#   name: String
# }

"""
Indexer represents metadata of the indexer all of its stake and delegator stake
"""
type Indexer @entity {
  "Eth address of Indexer"
  id: ID!
  "Time this indexer was created"
  createdAt: Int!
  "Graph account of this indexer"
  account: GraphAccount!
  "Service registry URL string"
  urlString: String
  "Geohash of the indexer"
  geoHash: String
  "Total tokens staked"
  stakedTokens: BigInt!
  "Total tokens allocated"
  tokensAllocated: BigInt!
  "Total tokens locked"
  tokensLocked: BigInt!
  "Tokens settled and waiting to be claimed"
  tokensClaimable: BigInt!
  "Time when Indexers tokens unlock"
  tokensLockedUntil: Int!
  "Channels this indexer is currently staked on"
  channels: [Channel!]! @derivedFrom(field: "indexer")

  # Delegator fields
  "Delegators to this Indexer"
  delegators: [DelegatedStake!]! @derivedFrom(field: "indexer")
  "Total tokens delegated to the indexer"
  tokensDelegated: BigInt!
  "Total tokens available to be delegated"
  tokenCapacity: BigInt!
  "The percent the Indexer agrees to share with delegators"
  indexingRewardCut: Int!
  "The percent of query rebate rewards the Indexer agrees to share with delegators"
  queryFeeCut: Int!
  "Time delegator decides to wait for changing of their parameters"
  delegatorParameterCooldown: Int!
  "Count of how many times this indexer has been forced to settle"
  forcedSettlements: Int!
}

"""
Allocation represents the continuous stake of an Indexer on a Subgraph deployment which is the accumulation of Channels between an indexer and a subgraph
"""
type Allocation @entity {
  "Indexer ID concatenated with the Subgraph Deployment ID"
  id: ID!
  "Indexer of this Allocation"
  indexer: Indexer!
  "Subgraph of this Allocation"
  subgraphDeployment: SubgraphDeployment!
  "Active Channel. Null if this Indexer is no longer indexing this subgraph deployment"
  activeChannel: Channel
  "Past channels and active channel for this Allocation"
  channels: [Channel!]! @derivedFrom(field: "allocation")
}

"""
State channel allocation representing Indexer-SubgraphDeployment stake
"""
type Channel @entity {
  "Channel Address"
  id: ID!
  "Indexer of this channel"
  indexer: Indexer!
  "Subgraph deployment that is being staked on with an open channel"
  subgraphDeployment: SubgraphDeployment!
  "Allocation this channel is a part of"
  allocation: Allocation!
  "Tokens associated with the channel"
  tokensAllocated: BigInt!
  "Epoch this channel was created"
  createdAtEpoch: Int!
  "Fees this channel collected upon closing. Excludes curator reward"
  feesCollected: BigInt!
  "Curator rewards deposited to the curating bonding curve"
  curatorReward: BigInt!
  "Epoch number of the Pool it was settled in"
  settled: Pool
  "Whether or not the channel has been claimed"
  claimed: Boolean!
}

"""
Global pool of query fees for settled state channels after Curation rewards have been removed. One pool per epoch
"""
type Pool @entity {
  "Epoch number of the pool"
  id: ID!
  "Total effective allocation settled in this epoch"
  allocation: BigInt!
  "Total fees in this epoch"
  fees: BigInt!
  "Total fees claimed in this epoch"
  feesClaimed: BigInt!
  "Total rewards deposited to all curator bonding curves during the epoch"
  curatorReward: BigInt!
  "Channels that were settled during this epoch"
  settled: [Channel!]! @derivedFrom(field: "settled")
}

"""
All data regarding an Indexing Reward
"""
type IndexingReward @entity {
  "Reward ID"
  id: ID!
  "Minted GRT in this epoch"
  mintedGRT: BigInt!
  "Epoch the reward was handed out"
  epoch: Int!
  "Total allocation settled in this epoch"
  allocation: BigInt!
  "Subgraph deployment that won durning this epoch"
  subgraphDeployment: SubgraphDeployment!
  "Winning Indexer"
  indexer: Indexer!
  "True if reward has been claimed"
  claimed: Boolean!
}

"""
Delegator with all their stakes
"""
type Delegator @entity {
  "Delegator address"
  id: ID!
  "Stakes of this delegator"
  stakes: [DelegatedStake!]! @derivedFrom(field: "delegator")
}

"""
Delegator stake for a single Indexer
"""
type DelegatedStake @entity {
  "Concatenation of Delegator address and Indexer address"
  id: ID!
  "Index the stake is delegated to"
  indexer: Indexer!
  "Delegator"
  delegator: Delegator!
  "Amount delegated"
  stake: BigInt!
}

"""
Curator with all their signals
"""
type Curator @entity {
  "Eth address of the Curator"
  id: ID!
  "Time this curator was created"
  createdAt: Int!
  "Graph account of this curator"
  account: GraphAccount!
  "Total minted signal this curator has on all subgraphs"
  totalSignal: BigInt!
  "Total GRT signaled on all the subgraphs"
  totalSignaledGRT: BigInt!
  "Total GRT redeemed on all the subgraphs"
  totalRedeemedGRT: BigInt!
  "Subgraphs the curator is curating"
  signals: [Signal!]! @derivedFrom(field: "curator")
}

"""
Curator signal for a single Subgraph deployment
"""
type Signal @entity {
  "Eth address + subgraph deployment ID"
  id: ID!
  "Eth address of the curator"
  curator: Curator!
  "Subgraph being signaled"
  subgraphDeployment: SubgraphDeployment!
  "Cumulative number of tokens the curator has signaled"
  tokensSignaled: BigInt!
  "Cumulative number of tokens the curator has redeemed"
  tokensRedeemed: BigInt!
  "Signal that the curator has from signaling their GRT"
  signal: BigInt!
}

"""
Dispute of a query. Includes both normal and attestation Disputes
"""
type Dispute @entity {
  "Dispute ID"
  id: ID!
  "Subgraph deployment being disputed"
  subgraphDeployment: SubgraphDeployment!
  "Indexer disputed. If an attestation dispute there will be 2 indexers"
  indexers: [Indexer!]!
  "Fisherman address"
  fisherman: Bytes!
  "Fisherman deposit"
  deposit: BigInt!
  "Attestation disputed. If an attestation dispute there will be 2 attestation"
  attestation: [Attestation!]!
  "Time dispute was created"
  createdAt: Int!
  "Result of either type of dispute"
  result: DisputeResult!
  "Tokens slashed"
  tokensSlashed: BigInt!
  "Tokens rewarded"
  tokensRewarded: BigInt!
}

"""
Attestation of a dispute
"""
type Attestation @entity {
  "Concatenation of the requestCID and responseCID"
  id: ID!
  "Subgraph deployment being disputed"
  subgraphDeployment: SubgraphDeployment!
  "RequestCID"
  requestCID: String!
  "ResponseCID"
  responseCID: String!
  "Gas used by the attested query"
  gasUsed: BigInt!
  "Bytes of attested query"
  responseNumBytes: BigInt!
  "V of the indexers signature"
  v: Int!
  "R of the indexers signature"
  r: Bytes!
  "S of the indexers signature"
  s: Bytes!
}

enum DisputeResult {
  Undecided
  Accepted
  Rejected
  Draw
  Indexer1Correct
  Indexer2Correct
}
