"""
Graph Network global parameters
"""
type GraphNetwork @entity {
  "ID is set to 1"
  id: ID!
  "Contract address"
  graphToken: Bytes!
  "Contract address"
  epochManager: Bytes!
  "Contract address"
  curation: Bytes!
  "Contract address"
  staking: Bytes!
  "Contract address"
  disputeManager: Bytes!
  "Contract address"
  gns: Bytes!
  "Contract address"
  serviceRegistry: Bytes!
  # "Set to true if the protocol is paused" TODO - add when implemented
  # paused: Boolean!

  # Staking global variables
  "Percentage of fees going to curators"
  curationPercentage: BigInt!
  "Percentage of fees burn as protocol fee"
  protocolPercentage: BigInt!
  "Ratio of staked delegation tokens to indexers stake"
  delegationCapacity: Int!
  "Period to wait before fees can be claimed in rebate pool"
  channelDisputeEpochs: BigInt!
  "Period to wait before delegators can settle"
  maxAllocationEpochs: BigInt!
  "Time in blocks needed to wait to unstake"
  thawingPeriod: BigInt!
  # "All addresses that have slashing privileges" TODO - add when implemented
  # slashers: [Bytes!]!
  "Minimum time an Indexer must use for resetting their Delegation parameters"
  minDelegationParameterCooldown: Int!
  "The number of times indexing rewards are handed out each epoch"
  indexingRewardsPerEpoch: Int!
  "The issuance rate that GRT is minted at to be rewarded to staked Indexers"
  networkGRTIssuance: Int!
  "The total amount of GRT staked in the staking contract"
  totalGRTStaked: BigInt!
  "Total tokens that are settled and waiting to be claimed"
  totalGRTClaimable: BigInt!
  "Total tokens that are currently locked in the network"
  totalGRTLocked: BigInt!
  "Total GRT currertly in allocation"
  totalGRTAllocated: BigInt!
  "Total query fees collected in the network"
  totalQueryFees: BigInt!

  # Curation global variables
  "Default reserve ratio for all subgraphs"
  defaultReserveRatio: BigInt!
  "Minimum amount of tokens needed to start curating"
  minimumCurationSignal: BigInt!
  "The total amount of GRT staked in the Curation contract"
  totalGRTSignaled: BigInt!
  "The fee charged when a curator withdraws stake"
  withdrawalFeePercentage: BigInt!

  # Graph Token global variables
  "Graph Token supply"
  totalSupply: BigInt!
  "Price of one GRT in USD"
  GRTinUSD: BigDecimal!
  "Price of one GRT in ETH"
  GRTinETH: BigDecimal

  # Epoch manager global variables
  "Epoch Length in blocks"
  epochLength: Int!
  "Epoch that was last run"
  lastRunEpoch: Int!
  "Epoch when epoch length was last updated"
  lastLengthUpdateEpoch: Int!
  "Block when epoch length was last updated"
  lastLengthUpdateBlock: Int!

  # Dispute Manager global variables TODO - add in later on in testnet
  "Penalty to Indexer on successful disputes"
  slashingPercentage: BigInt!
  # "Address with permission to verify or reject disputes"
  # arbitrator: Bytes!
  # "Minimum deposit to create a dispute"
  # minimumDisputeDeposit: BigInt!
  # "Reward to Fisherman on successful disputes"
  # fishermanRewardPercentage: BigInt!

}

"""
An account within the graph network
"""
type GraphAccount @entity {
  "Graph account ID"
  id: ID!
  "All names this graph account has claimed from all name systems"
  names: [GraphAccountName!]! @derivedFrom(field: "graphAccount")
  "Default name the graph account has chosen"
  defaultName: GraphAccountName
  "Time the account was created"
  createdAt: Int!
  "True if it is an organization. False if it is an individual"
  isOrganization: Boolean!
  "IPFS hash with account metadata details"
  metadataHash: Bytes
  "Main repository of code for the graph account"
  codeRepository: String
  "Description of the graph account"
  description: String
  "Name of the graph account"
  displayName: String # TODO - ask nena if she still wants this
  "Image in string format"
  image: String
  "Website URL"
  website: String
  "Delegate of other Graph Accounts"
  delegateOf: [GraphAccount!]! @derivedFrom(field: "delegates")
  "Delegates of this Graph Accounts"
  delegates: [GraphAccount!]!
  "Graph token balance"
  balance: BigInt!

  # Subgraphs
  "Subgraphs the graph account owns"
  subgraphs: [Subgraph!]! @derivedFrom(field: "owner")
  "Time that this graph account became a developer"
  firstSubgraphCreatedAt: Int!
  "Total query fees the subgraphs created by this account have accumulated"
  queryFeesEarnedFromSubgraphs: BigInt! # Phase 1 this will always be 0

  #Staking and Curating and Delegating
  "Subgraphs this account curates"
  curator: Curator
  "Subgraphs this account indexes"
  indexer: Indexer
  "Subgraphs this account has delegated to"
  delegator: Delegator
}

"""
A name and a name system. A graph account can own many names from many systems
"""
type GraphAccountName @entity {
  "Name system concatenated with the unique ID of the name system"
  id: ID!
  "Name system for this name"
  nameSystem: NameSystem!
  "Name from the system"
  name: String!
  "The graph account that owned the name when it was linked in the graph network"
  graphAccount: GraphAccount! # May not match if the graph account proceeded to transfer away their name on that system

}

enum NameSystem {
  ENS
  # Everest # Add when implemented
  # Github  # Add when implemented
}

"""
Named subgraph data
"""
type Subgraph @entity {
  "Subgraph ID derived from the Organization/Individual graph accountID"
  id: ID!
  "Graph account that owns this subgraph"
  owner: GraphAccount!
  "Current version. Null if the subgraph is deprecated"
  currentVersion: SubgraphVersion
  "Past versions"
  pastVersions: [SubgraphVersion!]!
  "Creation timestamp"
  createdAt: Int!

  # Name curation data
  "Total GRT signaled for the name"
  totalNameSignaledGRTStaked: BigInt!
  "Total GRT signaled for the name"
  totalNameSignaledGRTRedeemed: BigInt!
  "Total name signal minted for this subgraph"
  totalNameSignalMinted: BigInt!

  # Metadata from IPFS linked in GNS
  "Subgraph metadata"
  metadataHash: Bytes!
  "Short description of the subgraph"
  description: String!
  "Image in string format"
  image: String!
  "Location of the code for this project"
  codeRepository: String!
  "Project's website"
  website: String!
  "Display name"
  displayName: String!

  # Aggregate data, by combining all versions, and all deployments those versions point to 
  "Total inflation rewards earned all time by this subgraph"
  totalSubgraphIndexingRewards: BigInt!
  "Total query fees earned by this subgraph"
  totalQueryFeesCollected: BigInt!
  "Total stake of all indexers on all subgraph versions. Includes delegation"
  totalStake: BigInt!
  "Total signal of all curators on all subgraph versions"
  totalSignal: BigInt!
}

"""
Contains all the version metadata
"""
type SubgraphVersion @entity {
  "Concatenation of subgraph, subgraph deployment, and version ID"
  id: ID!
  "Subgraph of this version"
  subgraph: Subgraph!
  "Subgraph depolyment of this version"
  subgraphDeployment: SubgraphDeployment!
  "Version number"
  version: Int!
  "Creation timestamp"
  createdAt: Int!

  # Metadata from IPFS linked in GNS
  "Subgraph version metadata content address"
  metadataHash: Bytes!
  "Short description of the version"
  description: String!
  "A human readable name. If not set, blank string"
  label: String!
}

"""
The immutable subgraph deployment defined by a subgraph manifest that gets staked and signaled on
"""
type SubgraphDeployment @entity {
  "Subgraph Deployment ID"
  id: ID!
  "The versions this subgraph deployment relates to"
  versions: [SubgraphVersion!]! @derivedFrom(field: "subgraphDeployment")
  "Creation timestamp"
  createdAt: Int!

  # From Staking
  "Total stake of all indexers on this Subgraph deployment"
  totalStake: BigInt!
  "Allocations created by indexers for this subgraph"
  indexerAllocations: [Allocation!]! @derivedFrom(field: "subgraphDeployment")
  "Total fees accrued all time by this subgraph deployment"
  totalSubgraphIndexingRewards: BigInt!
  "Total query fees earned by this subgraph deployment"
  totalQueryFeesCollected: BigInt!

  # Subgraph deplyoment bonding curve
  "Total signaled GRT"
  totalSignaledGRT: BigInt!
  "Total curation signal created for this subgraph deployment"
  totalSignalMinted: BigInt!
  "Total curator reward from fees"
  totalCuratorFeeReward: BigInt!

  "Curators of this subgraph deployment"
  curatorSignals: [Signal!]! @derivedFrom(field: "subgraphDeployment")
  "Bonding curve reserve ratio"
  reserveRatio: BigInt

  # From Subgraph Manifest
  # dataSources: [DataSource!] # TODO - add a ! when we have the ability to parse data sources
}

# TODO - add when we have the ability to parse data sources
# """Data source obtained from the subgraph manifest"""
# type DataSource @entity {
#   "Unique identifier of the data source. Such as contract address"
#   id: ID!
#   "Data source name in the manifest"
#   name: String!
#   "Networks that the subgraph deployment is indexing"
#   networks: [String!]!
#   "Contract"
#   contract: Contract!
#   "ABI of the contract"
#   abi: String!
# }

# type Contract @entity {
#   "Address of the contract"
#   id: ID!
#   "Contract name"
#   name: String
# }

"""
Metadata for the indexer along with its parameters stake and delegator stake
"""
type Indexer @entity {
  "Eth address of Indexer"
  id: ID!
  "Time this indexer was created"
  createdAt: Int!
  "Graph account of this indexer"
  account: GraphAccount!
  "Service registry URL string"
  url: String
  "Geohash of the indexer"
  geoHash: String
  "Total tokens staked"
  tokensStaked: BigInt!
  "Total tokens allocated"
  tokensAllocated: BigInt!
  "Total tokens locked"
  tokensLocked: BigInt!
  "Tokens settled and waiting to be claimed"
  tokensClaimable: BigInt!
  "Time when Indexers tokens unlock"
  tokensLockedUntil: Int!
  "Allocations this indexer is currently staked on"
  allocations: [Allocation!]! @derivedFrom(field: "indexer")
  "Total query fees earned by this indexer"
  queryFeesEarned: BigInt!
  "Total rewards earned bu this indexer"
  rewardsEarned: BigInt!

  # Delegation Pool
  "Delegators to this Indexer"
  delegators: [DelegatedStake!]! @derivedFrom(field: "indexer")
  "Total tokens delegated to the indexer"
  tokensDelegated: BigInt!
  "Total shares of the delegator pool"
  delegatorShares: BigInt!
  "Total tokens available to be delegated"
  tokenCapacity: BigInt!
  "The percent the Indexer agrees to share with delegators"
  indexingRewardCut: Int!
  "The percent of query rebate rewards the Indexer agrees to share with delegators"
  queryFeeCut: Int!
  "Time delegator decides to wait for changing of their parameters"
  delegatorParameterCooldown: Int!
  "Block number for the last time the delegator updated their parameters"
  lastDelgationParameterUpdate: Int!
  "Count of how many times this indexer has been forced to settle"
  forcedSettlements: Int!

  # Metrics
  "Total return this indexer has earned"
  return: BigDecimal!
  "Annualized rate of return for the indexer"
  annualizedReturn: BigDecimal! # You must multiple by 100 to get percentage
  "Staking efficiency of the indexer"
  stakingEfficiency: BigDecimal! # Phase 1 this will always be 0
}

"""
State channel allocation representing Indexer-SubgraphDeployment stake
"""
type Allocation @entity {
  "Channel Address"
  id: ID!
  "Uncompressed public key of the channel"
  publicKey: Bytes!
  "Indexer of this allocation"
  indexer: Indexer!
  "Subgraph deployment that is being staked on with an open allocation"
  subgraphDeployment: SubgraphDeployment!
  "Tokens associated with the allocation"
  tokensAllocated: BigInt!
  "Epoch this allocation was created"
  createdAtEpoch: Int!
  "Fees this allocation collected upon closing. Excludes curator reward"
  feesCollected: BigInt!
  "Curator rewards deposited to the curating bonding curve"
  curatorReward: BigInt!
  "Epoch number of the Pool it was settled in"
  poolSettled: Pool
  "Whether or not the allocation has been claimed"
  claimed: Boolean!
  "Fees paid out to delegators"
  delegationFees: BigInt!
  "Status of the allocation"
  allocationStatus: AllocationStatus!

  # Metrics
  return: BigDecimal!
  "Yearly annualzied return"
  annualizedReturn: BigDecimal!
}

enum AllocationStatus {
  Null
  Claimed
  Active
  Finalized
  Settled
}

"""
Global pool of query fees for settled state channels. One pool per epoch
"""
type Pool @entity {
  "Epoch number of the pool"
  id: ID!
  "Total effective allocation settled in this epoch"
  allocation: BigInt!
  "Total fees in this epoch"
  fees: BigInt!
  "Total fees claimed in this epoch"
  feesClaimed: BigInt!
  "Total rewards deposited to all curator bonding curves during the epoch"
  curatorReward: BigInt!
  "Allocations that were settled during this epoch"
  settled: [Allocation!]! @derivedFrom(field: "poolSettled")
}

"""
All data regarding an Indexing Reward
"""
type IndexingReward @entity {
  "Reward ID"
  id: ID!
  "Minted GRT in this epoch"
  mintedGRT: BigInt!
  "Epoch the reward was handed out"
  epoch: Int!
  "Total allocation settled in this epoch"
  allocation: BigInt!
  "Subgraph deployment that won durning this epoch"
  subgraphDeployment: SubgraphDeployment!
  "Winning Indexer"
  indexer: Indexer!
  "True if reward has been claimed"
  claimed: Boolean!
}

"""
Delegator with all their stakes
"""
type Delegator @entity {
  "Delegator address"
  id: ID!
  "Stakes of this delegator"
  stakes: [DelegatedStake!]! @derivedFrom(field: "delegator")
  "Summation of all staked amounts in DelegatorStakes of this Delegator"
  totalStaked: BigInt!
  "Summation of all unstaked amounts in DelegatorStakes of this Delegator"
  totalUnstaked: BigInt!
  "Time created at"
  createdAt: Int!
}

"""
Delegator stake for a single Indexer
"""
type DelegatedStake @entity {
  "Concatenation of Delegator address and Indexer address"
  id: ID!
  "Index the stake is delegated to"
  indexer: Indexer!
  "Delegator"
  delegator: Delegator!
  "Amount delegated"
  stake: BigInt!
  "Amount un-delegated"
  unstaked: BigInt!
  "Shares owned in the delegator pool"
  shares: BigInt!
}

"""
Curator with all their signals
"""
type Curator @entity {
  "Eth address of the Curator"
  id: ID!
  "Time this curator was created"
  createdAt: Int!
  "Graph account of this curator"
  account: GraphAccount!
  "Total minted signal this curator has on all subgraphs"
  totalSignal: BigInt!
  "Total GRT signaled on all the subgraphs"
  totalSignaledGRT: BigInt!
  "Total GRT redeemed on all the subgraphs"
  totalRedeemedGRT: BigInt!
  "Subgraphs the curator is curating"
  signals: [Signal!]! @derivedFrom(field: "curator")


  # Metrics
  "Summation of realized rewards from all Signals"
  realizedRewards: BigInt!
  "Annualized rate of return on curator signal"
  annualizedReturn: BigDecimal! # Multiple by 100 to get percentage
  "Total return of the curator"
  return: BigInt!
  "Signaling efficiency of the curator"
  signalingEfficiency: BigInt! # Phase 1 this will always be 0
}

"""
Curator signal for a single Subgraph deployment
"""
type Signal @entity {
  "Eth address + subgraph deployment ID"
  id: ID!
  "Eth address of the curator"
  curator: Curator!
  "Subgraph being signaled"
  subgraphDeployment: SubgraphDeployment!
  "Cumulative number of tokens the curator has signaled"
  tokensSignaled: BigInt!
  "Cumulative number of tokens the curator has redeemed"
  tokensRedeemed: BigInt!
  "Signal that the curator has from signaling their GRT"
  signal: BigInt!

  # Metrics
  "Block for which the curator last entered or exited the curve"
  lastSignalChange: Int!
  # These are summed up and added whenever curator enters or exists the curve. Then we must calculate
  # unrealized gains for their current balance, based on the time since the last exit/entry of the curve
  "Summation of realized rewards from before the last time the curator entered the curation curve"
  realizedRewards: BigInt!
}

"""
Dispute of a query. Includes both normal and attestation Disputes
"""
type Dispute @entity {
  "Dispute ID"
  id: ID!
  "Subgraph deployment being disputed"
  subgraphDeployment: SubgraphDeployment!
  "Indexer disputed. If an attestation dispute there will be 2 indexers"
  indexers: [Indexer!]!
  "Fisherman address"
  fisherman: Bytes!
  "Fisherman deposit"
  deposit: BigInt!
  "Attestation disputed. If an attestation dispute there will be 2 attestation"
  attestation: [Attestation!]!
  "Time dispute was created"
  createdAt: Int!
  "Result of either type of dispute"
  result: DisputeResult!
  "Tokens slashed"
  tokensSlashed: BigInt!
  "Tokens rewarded"
  tokensRewarded: BigInt!
}

"""
Attestation of a dispute
"""
type Attestation @entity {
  "Concatenation of the requestCID and responseCID"
  id: ID!
  "Subgraph deployment being disputed"
  subgraphDeployment: SubgraphDeployment!
  "RequestCID"
  requestCID: String!
  "ResponseCID"
  responseCID: String!
  "Gas used by the attested query"
  gasUsed: BigInt!
  "Bytes of attested query"
  responseNumBytes: BigInt!
  "V of the indexers signature"
  v: Int!
  "R of the indexers signature"
  r: Bytes!
  "S of the indexers signature"
  s: Bytes!
}

enum DisputeResult {
  Undecided
  Accepted
  Rejected
  Draw
  Indexer1Correct
  Indexer2Correct
}

"""
Epoch data
"""
type Epoch @entity {
  "Epoch number"
  id: ID! 
  "Start block of the epoch"
  startBlock: Int!
  "End block of the epoch"
  endBlock: Int!
  "Signal created during this epoch"
  signalCreated: Int! # sum(signal - unsignaled)
  "Stake deposited during this epoch"
  stakeDeposited: Int! # sum(stake - unstake)
  "Query fees collected during this epoch"
  totalQueryFees: Int!
  "Status of the Epoch"
  status: EpochStatus!
}

enum EpochStatus {
  Settling
  Rewarding
  Finalized
}